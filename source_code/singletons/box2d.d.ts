import * as LittleJS from 'littlejsengine';


export function box2dRaycastAll(start: any, end: any): any[];
export function box2dRaycast(start: any, end: any): any;
export function box2dBoxCastAll(pos: any, size: any): any[];
export function box2dBoxCast(pos: any, size: any): undefined;
export function box2dCircleCastAll(pos: any, diameter: any): any[];
export function box2dCircleCast(pos: any, diameter: any): any;
export function box2dPointCast(pos: any, dynamicOnly?: boolean): undefined;
export function box2dBoxCastAllFixtures(pos: any, size: any): any[];
export function box2dCreateMouseJoint(object: any, fixedObject: any, worldPos: any): any;
export function box2dCreatePinJoint(objectA: any, objectB: any, collide?: boolean): any;
export function box2dCreateDistanceJoint(objectA: any, objectB: any, anchorA: any, anchorB: any, collide?: boolean): any;
export function box2dCreateRevoluteJoint(objectA: any, objectB: any, anchor: any, collide?: boolean): any;
export function box2dCreatePrismaticJoint(objectA: any, objectB: any, anchor: any, worldAxis?: any, collide?: boolean): any;
export function box2dCreateWheelJoint(objectA: any, objectB: any, anchor: any, worldAxis?: any, collide?: boolean): any;
export function box2dCreateWeldJoint(objectA: any, objectB: any, anchor: any, collide?: boolean): any;
export function box2dCreateFrictionJoint(objectA: any, objectB: any, anchor: any, collide?: boolean): any;
export function box2dCreateRopeJoint(objectA: any, objectB: any, anchorA: any, anchorB: any, extraLength?: number, collide?: boolean): any;
export function box2dCreatePulleyJoint(objectA: any, objectB: any, groundAnchorA: any, groundAnchorB: any, anchorA: any, anchorB: any, ratio?: number, collide?: boolean): any;
export function box2dCreateMotorJoint(objectA: any, objectB: any): any;
export function box2dCreateGearJoint(objectA: any, objectB: any, joint1: any, joint2: any, ratio?: number): any;
export  function box2dDestroyJoint(joint: any): void;
export function box2dIsNull(object: any): boolean;
export  function box2dCreateFixtureDef(shape: any, density?: number, friction?: number, restitution?: number, isSensor?: boolean): any;
export  function box2dCreatePointList(points: any): any;
export  function box2dCreatePolygonShape(points: any): any;
export  function box2dCastObject(object: any): any;
export  function box2dWarmup(frames?: number): void;
export  function box2dDrawFixture(fixture: any, pos: any, angle: any, fillColor: any, outlineColor: any, lineWidth: any): void;
export  function box2dDrawCircle(pos: any, radius: any, color: any, outlineColor: any, lineWidth: number, context: any): void;
export  function box2dDrawPoly(pos: any, angle: any, points: any, color: any, outlineColor: any, lineWidth: number, context: any): void;
export  function box2dDrawLine(pos: any, angle: any, posA: any, posB: any, color: any, lineWidth: number, context: any): void;
export  function box2dDrawFillStroke(context: any, color: any, outlineColor: any, lineWidth: any): void;
export function box2dEngineInit(gameInit: any, gameUpdate: any, gameUpdatePost: any, gameRender: any, gameRenderPost: any, imageSources: any): void;
export let box2d: any;
export let box2dWorld: any;
export let box2dDebugDraw: any;
export let box2dDebug: boolean;
export let box2dStepIterations: number;
export const box2dBodyTypeStatic: 0;
export const box2dBodyTypeKinematic: 1;
export const box2dBodyTypeDynamic: 2;
// to do:
// (1) add LittleJS types to the declaration
export class Box2dObject {
    constructor(
        pos: LittleJS.Vector2, 
        size: LittleJS.Vector2, 
        tileInfo: any, angle: number, color: any, bodyType?: number, renderOrder?: number);
    body: any;
    outlineColor: any;
    destroy(): void;
    update(): void;
    angle: any;
    render(): void;
    renderDebugInfo(): void;
    box2dDrawFixtures(fillColor: any, outlineColor: any, lineWidth?: number): void;
    beginContact(otherObject: any, contact: any): void;
    endContact(otherObject: any, contact: any): void;
    addFixture(fixtureDef: any): any;
    addShape(shape: any, density: any, friction: any, restitution: any, isSensor: any): any;
    addBox(size: any, offset: any, angle: number, density: any, friction: any, restitution: any, isSensor: any): any;
    addPoly(points: any, density: any, friction: any, restitution: any, isSensor: any): any;
    addRegularPoly(diameter: number, sides: number, density: any, friction: any, restitution: any, isSensor: any): any;
    addRandomPoly(diameter: number, density: any, friction: any, restitution: any, isSensor: any): any;
    addCircle(diameter: number, offset: any, density: any, friction: any, restitution: any, isSensor: any): any;
    addEdge(point1: any, point2: any, density: any, friction: any, restitution: any, isSensor: any): any;
    addEdgeLoop(points: any, density: any, friction: any, restitution: any, isSensor: any): any[];
    addEdgeList(points: any, density: any, friction: any, restitution: any, isSensor: any): any[];
    hasFixtures(): boolean;
    getFixtureList(): any[];
    hasJoints(): boolean;
    getJointList(): any[];
    getCenterOfMass(): any;
    getLinearVelocity(): any;
    getAngularVelocity(): any;
    getMass(): any;
    getInertia(): any;
    getIsAwake(): any;
    getBodyType(): any;
    getIsStatic(): boolean;
    getIsKinematic(): boolean;
    getIsDynamic(): boolean;
    setTransform(position: any, angle: any): void;
    pos: any;
    setPosition(position: any): void;
    setAngle(angle: any): void;
    setLinearVelocity(velocity: any): void;
    setAngularVelocity(angularVelocity: any): void;
    setLinearDamping(damping: any): void;
    setAngularDamping(damping: any): void;
    setGravityScale(scale?: number): void;
    gravityScale: number;
    setBullet(isBullet?: boolean): void;
    setAwake(isAwake?: boolean): void;
    setBodyType(type: any): void;
    setSleepingAllowed(isAllowed?: boolean): void;
    setFixedRotation(isFixed?: boolean): void;
    setCenterOfMass(center: any): void;
    setMass(mass: any): void;
    setMomentOfInertia(I: any): void;
    resetMassData(): void;
    setMassData(localCenter: any, mass: any, momentOfInertia: any): void;
    setFilterData(categoryBits?: number, ignoreCategoryBits?: number, groupIndex?: number): void;
    setSensor(isSensor?: boolean): void;
    applyForce(force: any, pos: any): void;
    applyAcceleration(acceleration: any, pos: any): void;
    applyTorque(torque: any): void;
    applyAngularAcceleration(acceleration: any): void;
}
export class Box2dRaycastResult {
    constructor(fixture: any, point: any, normal: any, fraction: any);
    fixture: any;
    point: any;
    normal: any;
    fraction: any;
    object: any;
}
